---
format: 
  revealjs:
    slide-number: true
    logo: images/future-logo.png
    footer: <https://future.p2p.futureverse.org>
    include-in-header: heading-meta.html
    code-copy: true
    center-title-slide: false
    code-link: true
    code-overflow: wrap
    highlight-style: a11y
    width: 1600
    height: 900
    margin: 0.02
    theme: [simple, assets/futureverse.scss]
    css: [assets/custom.css, assets/syntax-highlight.css]
    chalkboard: 
      buttons: false
    preview-links: auto
    pointer:
      pointerSize: 32

revealjs-plugins:
  - pointer
  - bsicons

execute:
  eval: false
  echo: true

latinr:
  talk-number: 56
  video-title: Peer-to-Peer Parallelization in R (Henrik Bengtsson)
  video-mp4: 56_future_p2p.mp4
---
<!--
Title: future.p2p: Peer-to-Peer Compute Clusters in R
Author: Henrik Bengtsson

Parallel processing can speed up computationally intensive tasks. As the size of these tasks grows --- and as access to more CPU cores increases -- so does the demand for parallel-processing solutions. In R, the futureverse ecosystem has, over the past decade, become a popular go-to for parallel and distributed computing. Its simplicity and strict, minimalistic application programming interface (API) are key reasons for its success. Many R packages use futureverse internally for parallelization, making it extremely easy for end-users to scale up their analyses without needing to understand the technical details of running code in parallel.

With futureverse, users have many options for where their parallel R code runs. Anyone can parallelize on their personal notebook or any machine they have access to. Users with accounts on multiple machines can easily parallelize across them -- as long as they have SSH access -- e.g., office desktops, remote servers, or cloud instances. Those with access to high-performance computing (HPC) clusters can run R code in parallel via job schedulers like Slurm and SGE.

But not all users have access to powerful machines or computing environments. Some lose access to high-end compute resources when they finish school or leave a job. For them, running certain analyses becomes impractical -- code might take days or even weeks to complete. The 'future.p2p' package aims to solve this problem. It lets users come together and build a global, peer-to-peer (P2P) compute cluster. This way, they can share and harness compute power among one another. Setup is minimal and requires only basic knowledge of SSH and R.

Availability: https://future.p2p.futureverse.org/
-->


<h1>future.p2p: Peer-to-Peer<br>Compute Clusters in R</h1>

<h2>_- Share compute among friends across the world_</h2>

<br/>

### Henrik Bengtsson

University of California, San Francisco<br>
R Foundation, R Consortium<br>
{{< bi github >}} {{< bi mastodon >}} {{< bi bluesky >}} \@HenrikBengtsson<br>

![](images/future-logo.png){fig-alt="The hexlogo of the future package. A left-facing arrow with the text future underneath - both in bold style filled with yellow-to-orange vertical gradient. The background is dark blue with teeny star-shaped symbols in distance resembling looking deep out in the universe. The hexlogo is surrounded by a light-blue border." .absolute top=20 right=40 width="250"}
![](images/world-p2p-network-three-users.png){fig-alt="Illustration of three people working on laptops, positioned below a large globe with location markers connected by lines, representing global online collaboration." .absolute top=380 right=-10 width="350"}

<br/>

#### LatinR 2025 (2025W49)


## Future ... what?

### When you write

::: { .code-medium  }
```{.r}
a <- 1 + 2
```
:::

<br>

::: { .fragment }

### R does

::: { style="margin: 1ex" }
:::

![](images/chatgpt_20251116-box-1-open-code.png){ width="250" style="vertical-align: middle" }
<span class="fragment">
  <span class="right-large">‚ûî</span>
  ![](images/gemini_20251116-r-box-square.png){ width="150" style="vertical-align: middle" }
</span>
<span class="fragment">
  <span class="right-large">‚ûî</span>
  ![](images/chatgpt_20251116-box-1-open-result_3.png){ width="250" style="vertical-align: middle" }
</span>
<span class="fragment">
  <span class="right-large">‚ûî</span>
  <span class="code-large">a &leftarrow; 3</span>
</span>

:::


## Future ... what?

### When you write

::: { .code-medium  }
```{.r}
y <- slow_sum(1:10)
```
:::

<br>

::: { .fragment }

### R does

::: { style="display: flex; transform: scale(0.75); transform-origin: top left; margin-bottom: -5ex;" }

:::: { style="text-align: center; font-size: 150%;" }
![](images/chatgpt_20251116-box-2-open-code-data_1-10.png){ width="250" style="vertical-align: middle" }
::::
:::: { }
<span class="right-large">‚ûî</span>
::::
:::: { style="text-align: center; font-size: 150%;" }
![](images/gemini_20251116-r-box-square.png){ width="150" style="vertical-align: middle" }<br>
**1 minute**
::::

::::: { .fragment style="display: flex;" }

:::: { }
<span class="right-large">‚ûî</span>
::::
:::: { style="text-align: center; font-size: 150%;" }
![](images/chatgpt_20251116-box-2-open-result_55.png){ width="250" style="vertical-align: middle" }
::::

:::::
::::: { .fragment style="display: flex;" }

:::: { }
<span class="right-large">‚ûî</span>
<span class="code-large">y &leftarrow; 55</span>
::::

:::::

:::

:::


## Futures gives more control on R evaluates code

### R code

::: { .code-normal  }
```{.r}
y <- slow_sum(1:10)
```
:::


::::: { .fragment }

### Same R code using futures

::: { .code-normal }
```{.r}
f <- future( slow_sum(1:10) )
y <- value(f)
```
:::

:::::

::::: { .fragment }

### What R does

::: { style="display: flex; transform: scale(0.75); transform-origin: top left; margin-bottom: -5ex;" }

:::: { style="text-align: center; font-size: 150%;" }
![](images/chatgpt_20251116-box-2-open-code-data_1-10.png){ width="250" style="vertical-align: middle" }<br>
**future**
::::
:::: { }
<span class="right-large">‚ûî</span>
::::
:::: { style="text-align: center; font-size: 150%;" }
![](images/gemini_20251116-r-box-square.png){ width="150" style="vertical-align: middle" }<br>
**1 minute**
::::
:::: { }
<span class="right-large">‚ûî</span>
::::
:::: { style="text-align: center; font-size: 150%;" }
![](images/chatgpt_20251116-box-2-open-result_55.png){ width="250" style="vertical-align: middle" }<br>
**value**
::::
:::: { }
<span class="right-large">‚ûî</span>
<span class="code-large">y &leftarrow; 55</span>
::::

:::

:::::





## R evaluates code sequentially

### R code

::: { .code-normal  }
```{.r}
y1 <- slow_sum( 1:10)          # 1 minute
y2 <- slow_sum(11:20)          # 1 minute
y3 <- slow_sum(21:30)          # 1 minute
```
:::

### What R does

::: { style="width: 200%;" }

:::: { style="display: flex; transform: scale(0.5); transform-origin: top left; margin-bottom: -8ex; width: 200%;" .fragment }

::::: { }
![](images/chatgpt_20251116-box-2-open-code-data_1-10.png){ width="250" style="vertical-align: middle" }
<span class="right-large">‚ûî</span>
:::::

::::: { style="text-align: center; font-size: 150%;" }
![](images/gemini_20251116-r-box-square.png){ width="150" style="vertical-align: middle" }<br>
**1 minute**
:::::

::::: { }
<span class="right-large">‚ûî</span>
![](images/chatgpt_20251116-box-2-open-result_55.png){ width="250" style="vertical-align: middle" }
<span class="right-large">‚ûî</span>
<span class="code-large">y1 &leftarrow; 55</span>
:::::

::::


:::: { style="display: flex; transform: scale(0.5); transform-origin: top left; margin-bottom: -8ex; width: 200%;" .fragment }

::::: { }
![](images/chatgpt_20251116-box-2-open-code-data_11-20.png){ width="250" style="vertical-align: middle" }
<span class="right-large">‚ûî</span>
:::::

::::: { style="text-align: center; font-size: 150%;" }
![](images/gemini_20251116-r-box-square.png){ width="150" style="vertical-align: middle" }<br>
**1 minute**
:::::

::::: { }
<span class="right-large">‚ûî</span>
![](images/chatgpt_20251116-box-2-open-result_155.png){ width="250" style="vertical-align: middle" }
<span class="right-large">‚ûî</span>
<span class="code-large">y2 &leftarrow; 155</span>
:::::

::::


:::: { style="display: flex; transform: scale(0.5); transform-origin: top left; margin-bottom: -8ex; width: 200%;" .fragment }

::::: { }
![](images/chatgpt_20251116-box-2-open-code-data_21-30.png){ width="250" style="vertical-align: middle" }
<span class="right-large">‚ûî</span>
:::::

::::: { style="text-align: center; font-size: 150%;" }
![](images/gemini_20251116-r-box-square.png){ width="150" style="vertical-align: middle" }<br>
**1 minute**
:::::

::::: { }
<span class="right-large">‚ûî</span>
![](images/chatgpt_20251116-box-2-open-result_255.png){ width="250" style="vertical-align: middle" }
<span class="right-large">‚ûî</span>
<span class="code-large">y3 &leftarrow; 255</span>
:::::

::::

:::



## R with futures evaluates code parallelly

::: { .code-normal  }
```{.r}
f1 <- future( slow_sum( 1:10) )   # 0 seconds
f2 <- future( slow_sum(11:20) )   # 0 seconds
f3 <- future( slow_sum(21:30) )   # 0 seconds

y1 <- value(f1)                   # 1 minute
y2 <- value(f2)                   # at the same time
y3 <- value(f3)                   # at the same time
```
:::

. . .


::: { style="display: flex; transform: scale(0.5); transform-origin: top left; margin-bottom: -8ex; width: 200%;" }

::::: { style="display: flex; border: solid; 3px; border-radius: 1ex; padding: 2ex;" }
:::: { style="text-align: center; font-size: 150%;" }
![](images/chatgpt_20251116-box-2-open-code-data_1-10.png){ width="250" style="vertical-align: middle" }<br>
**future #1**
::::
:::: { style="text-align: center; font-size: 150%; margin-left: 2ex;" }
![](images/chatgpt_20251116-box-2-open-code-data_11-20.png){ width="250" style="vertical-align: middle" }<br>
**future #2**
::::
:::: { style="text-align: center; font-size: 150%; margin-left: 2ex;" }
![](images/chatgpt_20251116-box-2-open-code-data_21-30.png){ width="250" style="vertical-align: middle" }<br>
**future #3**
::::
:::::

:::: { }
<br><br><br>
<span class="right-large">‚ûî</span>
::::

:::: { style="text-align: center;" }
![](images/gemini_20251116-r-box-square.png){ width="120" style="vertical-align: middle" }<br>
![](images/gemini_20251116-r-box-square.png){ width="120" style="vertical-align: middle" }<br>
![](images/gemini_20251116-r-box-square.png){ width="120" style="vertical-align: middle" }<br>
**1 minute<br>total**
::::

::::: { .fragment style="display: flex;" }

:::: { }
<br><br><br>
<span class="right-large">‚ûî</span>
::::

::::: { style="display: flex; border: solid; 3px; border-radius: 1ex; padding: 2ex;" }
:::: { style="text-align: center; font-size: 150%;" }
![](images/chatgpt_20251116-box-2-open-result_55.png){ width="250" style="vertical-align: middle" }<br>
**value #1**
::::
:::: { style="text-align: center; font-size: 150%; margin-left: 2ex;" }
![](images/chatgpt_20251116-box-2-open-result_155.png){ width="250" style="vertical-align: middle" }<br>
**value #2**
::::
:::: { style="text-align: center; font-size: 150%; margin-left: 2ex;" }
![](images/chatgpt_20251116-box-2-open-result_255.png){ width="250" style="vertical-align: middle" }<br>
**value #3**
::::

:::::

:::: { }
<br><br><br>
<span class="right-large">‚ûî</span>
::::

:::: { .code-large style="padding: 1ex;" }
y1 &leftarrow; 55<br>
y2 &leftarrow; 155<br>
y3 &leftarrow; 255
::::

:::::

:::



## Futures are the core building block for parallel processing

The \{future\} package provides:

<table style="border: none; text-align: center; margin-top: 4ex;">
<tr style="border: 0; text-align: center;">
<td style="border: 0; text-align: center;">
![](images/chatgpt_20251116-box-2-open-code-data_1-10.png){ width="250" }
</td>
<td style="border: 0; text-align: center;">
![](images/chatgpt_20251116-box-closed-question-mark.png){ width="180" }
</td>
<td style="border: 0; text-align: center;">
![](images/chatgpt_20251116-box-2-open-result_55.png){ width="250" }
</td>
</tr>
<tr style="border: 0; text-align: center;">
<td style="border: 0; text-align: center; font-size: 150%;">`future()`</td>
<td style="border: 0; text-align: center; font-size: 150%;">`resolved()`</td>
<td style="border: 0; text-align: center; font-size: 150%;">`value()`</td>
</tr>
</table>


## Futures allows you to stick with your favorite coding style

Parallel alternatives to traditional, sequential functions:

```{r}
#| code-line-numbers: "1|"
ys <- lapply(xs, slow_sum)             # base R
ys <- future_lapply(xs, slow_sum)      # {future.apply}
```
<span style="height:10px"/>
<br>

. . .


```{r}
#| code-line-numbers: "1|"
ys <- xs |> map(slow_sum)              # {purrr}
ys <- xs |> future_map(slow_sum)       # {furrr}
```

. . .

<br>

* `lapply()`, `map()`, ... package things up in boxes and send them
  one at the time to R

* `future_lapply()`, `future_map()`, ... send the boxes to different
  parallel R workers üöÄ




## Future boxes can be sent anywhere you want

You can parallelize "boxes" on your current computer, e.g. one of

```{r}
plan(multisession)
plan(future.callr::callr)
plan(future.mirai::mirai_multisession)
```

. . .

<br>

You can distribute "boxes" to other computers, e.g. one of

```{r}
plan(cluster, workers = c("n1", "desktop", "server.myuniv.org"))
plan(future.batchtools::batchtools_slurm)
```

. . .

<br>

... and now you can send them to your friends too!


## {data-background-color=#D0F0FF}

<center style="font-size: 400%; padding-top: 1.5ex;">
Peer-to-Peer Computing<br>
</center>
<center style="font-size: 200%; padding-top: 1.5ex;">
 \- share compute among friends
</center>


## future.p2p: sharing compute among friends - it's easy!

<div style="height: 0.5ex"></div>

::: {.column width="73%" font="150%"}
```{r}
#| code-line-numbers: false
library(future)

plan(future.p2p::cluster, cluster="alice/friends")

ys <- xs |> furrr::future_map(slow_sum)
```

:::

![](images/world-p2p-network-three-users.png){fig-alt="Illustration of three people working on laptops, positioned below a large globe with location markers connected by lines, representing global online collaboration." .absolute top=280 right=-10 width="550"}



## A P2P cluster has two components

:::: {.fragment}

::: {.column width="65%" font="100%"}
<span style="font-size: 180%">Message Board</span>

Used to announce futures and offers to do work
<br>
(centralized; lightweight - only metadata)
:::

::: {.column width="30%" font="100%"}
![](images/message_board.png){fig-alt="Illustration of a bulletin board labeled 'Message Board' with six pinned notes, alternating between 'REQUEST' and 'OFFER' in yellow and blue squares." width="350"}
:::

::::

:::: {.fragment}

::: {.column width="65%" font="100%"}
<span style="font-size: 180%">P2P file-transfer protocol</span>

Used to send futures to workers and receive results
<br>
(peer-to-peer; full-size data transfers)
:::

::: {.column width="30%" font="100%"}
![](images/p2p-file-transfers.png){fig-alt="Diagram of three laptops connected in a triangular network, with arrows indicating file transfer between each pair." width="350"}
:::

::::


## Get started: To join a P2P cluster you need an account

All P2P cluster users need a [pico.sh](https://pico.sh) account to
access the message board:

:::: {.columns}

::: {.column width="50%" font-size="40%"}

### 1. `ssh-keygen`

![](images/ssh-keygen-carol.png){fig-alt="Terminal screenshot showing ssh-keygen generating a new ed25519 SSH key pair for user carol, including prompts for file location and passphrase, and displaying the key fingerprint and randomart image." width="770"}

:::

::: {.column width="50%"}

### 2. `ssh pico.sh` => pick a username

![](images/pico.sh-signup-carol.png){fig-alt="Terminal interface for pico.sh signup, showing welcome message, account creation instructions, a getting started link, the user's SSH public key fingerprint, and an input field with the username 'carol' entered." width="770"}

:::

::::

That's it!


## Get started: Try with personal P2P cluster

To test that everything works, create a personal P2P cluster that only
you have access to:

```{r}
#| code-line-numbers: false
library(future)
plan(future.p2p::cluster)
f <- future({ 1+2 })
v <- value(f)
print(v)
```

. . .

Nothing will be processed until you have added at least one P2P
worker. Open another R session and call:

```r
future.p2p::worker()
```

. . .

Momentarily, you should get the results:

```r
print(v)
#> [1] 3
```




## Alice hosts a P2P cluster

Alice sets up P2P cluster and gives 'bob' and 'carol' access:

```{r}
#| code-line-numbers: false
[alice]> future.p2p::host_cluster("alice/friends",
                                  users = c("bob", "carol"))
```

This is setting up a shared message board.

. . .

<br>
Q. What happens if Bob tries to use the P2P cluster?

```{r}
#| code-line-numbers: false
[bob]> plan(future.p2p::cluster, cluster = "alice/friends")
[bob]> ys <- xs |> future_map(slow_sum)
```

. . .

<br>

### Nothing - it will get stuck! Why?


## Contributing P2P workers is easy!

```{r}
#| code-line-numbers: false
[alice]> future.p2p::worker("alice/friends")
```
<div style="height:1ex;"></div>
```{r}
#| code-line-numbers: false
[ bob ]> future.p2p::worker("alice/friends")
```
<div style="height:1ex;"></div>
```{r}
#| code-line-numbers: false
[carol]> future.p2p::worker("alice/friends")
```

. . .

<br>

```{r}
#| code-line-numbers: false
[bob]> plan(future.p2p::cluster, cluster = "alice/friends")
[bob]> ys <- xs |> future_map(slow_sum)
```

<br>

### => Processed on three P2P workers



## Add more P2P workers at any time

```{r}
#| code-line-numbers: false
[alice]> future.p2p::worker("alice/friends")
[alice]> future.p2p::worker("alice/friends")
```
<div style="height:1ex;"></div>
```{r}
#| code-line-numbers: false
[ bob ]> future.p2p::worker("alice/friends")
```
<div style="height:1ex;"></div>
```{r}
#| code-line-numbers: false
[carol]> future.p2p::worker("alice/friends")
[carol]> future.p2p::worker("alice/friends")
[carol]> future.p2p::worker("alice/friends")
```

<span style="height:10px"/>
<span style="height:10px"/>

### => A shared P2P cluster with 6 workers.



## {data-background-color=#D0F0FF}

<center style="font-size: 400%; padding-top: 2.5ex;">
Pros and cons
</center>


## High throughput, but with high latency

* High throughput:

  - any number of users and workers can join
  
  - a public P2P cluster could have thousands of P2P workers

* High latency:

  - round-trip takes time, because p2p file transfers take time
  
  - Example: `1+2` takes 1-10 seconds to send, evaluate, and return

  - **This will improve!**





## ‚ö†Ô∏è P2P computing requires mutual trust ‚ö†Ô∏è

What if?

```{r}
#| code-line-numbers: false
f <- future(system("erase-harddrive"))
```

. . .

Risks can be mitigated by "sandboxing" workers, e.g.

   - in a virtual machine
   - in a Linux container
   - in webR (WebAssembly)
   
### => I encourage you to work on these important topics



## May the future be with you!

* It‚Äôs easy to get started - just try it
* Support: <https://github.com/orgs/futureverse/discussions>
* Tutorials: <https://www.futureverse.org/tutorials.html>
* Blog posts: <https://www.futureverse.org/blog.html>
* I love feedback, ideas, and bug reports üíú
* Lots of exiting improvements are coming your way!


![](images/futurize-v1.png){fig-alt="Hexagon-shaped logo with a light blue border, dark blue starry background, and the word 'FUTURIZE' in bold orange gradient letters beneath an upward-pointing arrow symbol." .absolute bottom=70 right=50 width="600"}
